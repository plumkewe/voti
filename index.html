<!DOCTYPE html>
<html lang="it">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Voti</title>
  <style>
    
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    
    body {
      font-family: "Roboto", sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      -webkit-user-select: none;  /* Safari, Chrome */
      -moz-user-select: none;     /* Firefox */
      -ms-user-select: none;      /* IE10+ */
      user-select: none;          /* Standard */
    }
    
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
      vertical-align: middle;
      font-size: 20px;
      cursor: default;
    }
    
    .file-upload {
      margin-top: 20px;
      margin-bottom: 2rem;
    }
    
    .file-upload label {
      background-color: #333;
      color: #e0e0e0;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      border: 1px solid #555;
    }
    
    .file-upload label:hover {
      background-color: #444;
    }
    
    .file-upload input {
      display: none;
    }
    
    /* Lista materie scorrevole orizzontalmente e centrata con max-width */
    .materie-lista {
      width: 100%;
      max-width: 1000px;      /* stessa larghezza massima della tabella */
      margin: 0 auto 1rem auto; /* centrata esattamente */
      display: flex;
      overflow-x: auto;
      padding: 0.5rem;
      background-color: #1e1e1e;
      border-radius: 8px;
      border: 1px solid #444;
      white-space: nowrap;
      
      /* Nasconde la scrollbar ma permette lo scroll */
      -ms-overflow-style: none;  /* IE e Edge */
      scrollbar-width: none;     /* Firefox */
    }
    
    .materie-lista::-webkit-scrollbar {
      display: none;             /* Chrome, Safari e Opera */
    }
    
    .materia-item {
      flex-shrink: 0;         /* evita che gli elementi si restringano */
      min-width: 120px;       /* larghezza minima coerente */
      display: flex;
      align-items: center;
      background-color: #2a2a2a;
      color: #e0e0e0;
      padding: 0.4rem 1rem;
      border-radius: 6px;
      margin-right: 0.5rem;
      cursor: pointer;
      user-select: none;
      font-size: 0.9rem;
      gap: 0.5rem;
      white-space: nowrap;
      transition: background-color 0.3s ease;
      border: 1px solid transparent;
    }
    
    
    .materia-item:hover,
    .materia-item.active {
      background-color: #444;
      border-color: #888;
    }
    
    .materia-item .tipo-count {
      display: flex;
      align-items: center;
      gap: 0.2rem;
      margin-left: 0.8rem;
    }
    
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 20;
      vertical-align: middle;
      font-size: 18px;
      cursor: default;
      user-select: none;
      color: #aaa;
    }
    
    .anni-lista {
      width: 100%;
      max-width: 1000px;
      margin: 0 auto 1rem auto;
      display: flex;
      overflow-x: auto;
      padding: 0.5rem;
      background-color: #1e1e1e;
      border-radius: 8px;
      border: 1px solid #444;
      white-space: nowrap;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .anni-lista::-webkit-scrollbar {
      display: none;
    }
    .anno-item {
      flex-shrink: 0;
      min-width: 80px;
      padding: 0.4rem 1rem;
      background-color: #2a2a2a;
      color: #e0e0e0;
      border-radius: 6px;
      margin-right: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
      border: 1px solid transparent;
      user-select: none;
      text-align: center;
    }
    .anno-item:hover,
    .anno-item.active {
      background-color: #444;
      border-color: #888;
    }
    
    /* Contenitore tabella centrato e larghezza massima */
    /* Contenitore tabella centrato con stessa max-width */
    .table-container {
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;          /* centrato */
      overflow-x: auto;
      border: 1px solid #444;
      border-radius: 8px;
      background-color: #1e1e1e;
    }
    
    /* Tabella */
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: inherit; /* eredita da .table-container */
      border-radius: 8px;
    }
    
    /* Celle */
    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #333;
      white-space: nowrap;
      min-width: 80px;      /* larghezza minima */
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Colonne specifiche con larghezza fissa per stabilità */
    th:nth-child(1), td:nth-child(1) { width: 40px; }   /* numero */
    th:nth-child(2), td:nth-child(2) { width: 180px; }  /* materia */
    th:nth-child(3), td:nth-child(3) { width: 100px; }  /* data */
    th:nth-child(4), td:nth-child(4) { width: 70px; }   /* voto */
    th:nth-child(5), td:nth-child(5) { width: 70px; }   /* tipo */
    
    th {
      background-color: #2a2a2a;
      color: #ffffff;
      font-weight: bold;
    }
    
    tr:nth-child(even) {
      background-color: #181818;
    }
    
    tr:last-child td {
      border-bottom: none;
    }
    
    /* Rimuove scroll inutili da body */
    html, body {
      overflow-x: hidden;
    }
    
    /* Palette di default (puoi modificarle a piacere) */
    :root {
      --color-anno-1: #4A90E2;
      --color-anno-2: #E94E77;
      --color-anno-3: #F5A623;
      --color-anno-4: #7ED321;
      --color-anno-5: #50E3C2;
    }
    #chartContainer {
      width: 100%;
      max-width: 700px;
      margin: 20px auto;
      height: 300px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .chart-item {
      flex-shrink: 0;
      min-width: 120px;
      padding: 0.4rem 1rem;
      background-color: #2a2a2a;
      color: #e0e0e0;
      border-radius: 6px;
      margin-right: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
      border: 1px solid transparent;
      user-select: none;
      text-align: center;
      transition: background-color 0.3s ease;
    }
    .chart-item:hover,
    .chart-item.active {
      background-color: #444;
      border-color: #888;
    }


    .chart-container {
      width: 100%;
      max-width: 1000px; /* come per le altre liste */
      margin: 0 auto 1rem auto;
      padding: 0.5rem;
      background-color: #1e1e1e;
      border-radius: 8px;
      border: 1px solid #444;
      
      display: flex;
      justify-content: center;
      align-items: center;
      
      /* Altezza fissa o massima altezza */
      height: 320px;  /* puoi regolare come vuoi */
      box-sizing: border-box;
      overflow: hidden;
    }
    
    
    #chartContainer {
      width: 100%;   /* qui verrà sovrascritto dinamicamente in JS */
      height: 100%;
      max-width: 700px; /* puoi rimuovere max-width se vuoi */
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: hidden; /* default, sarà modificato da JS */
    }
    
    button.sort-button {
      all: unset; /* reset completo dello stile nativo */
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: #e0e0e0;
      font-family: "Roboto", sans-serif;
      user-select: none;
    }
    
    button.sort-button .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 20;
      font-size: 18px;
      color: #aaa;
      user-select: none;
    }
  </style>
</head>
<body>
  
  <!-- Grafico -->
  <div class="chart-container">
    <div id="chartContainer">
      <canvas id="myChart"></canvas>
    </div>
  </div>

  
  <!-- Menu di selezione grafico -->
  <!-- Selezione tipo di grafico (stile come anni-lista) -->
  <div class="anni-lista" id="chartSelector">
    <div class="chart-item" data-type="tipo">Tipo</div>
    <div class="chart-item" data-type="quadrimestre">Quadrimestre</div>
    <div class="chart-item" data-type="mese">Mese</div>
    <div class="chart-item" data-type="media-mese">Media</div>
    <div class="chart-item" data-type="linea-anno-continuo">Linea Anno Continuo</div> <!-- Nuovo grafico -->
  </div>

  
  <div class="anni-lista" id="anniLista"></div>
  <div class="materie-lista" id="materieLista"></div>
  <div class="table-container">
    <table id="votiTable">
      <thead>
        <tr>
          <th>#</th>
          <th>MATERIA</th>
          <th>
            DATA
            <button id="sortDateBtn" class="sort-button" data-order="asc" aria-label="Ordina per data">
              <span class="material-symbols-outlined">swap_vert</span>
            </button>
          </th>
          <th>
            VOTO
            <button id="sortVotoBtn" class="sort-button" data-order="asc" aria-label="Ordina per voto">
              <span class="material-symbols-outlined">swap_vert</span>
            </button>
          </th>
          <th>TIPO</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  
  <div class="file-upload">
    <label for="csvFile">Carica file CSV</label>
    <input type="file" id="csvFile" accept=".csv" />
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    let selectedAnni = new Set(); // anni selezionati (es. "1A", "2A")

    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V"];
      return romans[num - 1] || num;
    }

    function buildAnniList(data) {
      const anniContainer = document.getElementById('anniLista');
      anniContainer.innerHTML = '';
      
      const anniSet = new Set(data.map(d => d.A));
      const anni = Array.from(anniSet).sort();
      
      anni.forEach(anno => {
        const div = document.createElement('div');
        div.className = 'anno-item' + (selectedAnni.has(anno) ? ' active' : '');
        const roman = toRoman(parseInt(anno));
        div.textContent = roman;
        div.onclick = () => {
          if (selectedAnni.has(anno)) {
            selectedAnni.delete(anno);
          } else {
            selectedAnni.add(anno);
          }
          updateFilter();
        };
        anniContainer.appendChild(div);
      });
    }
    
    
    
    function formatVoto(v) {
      const num = parseFloat(v);
      if (isNaN(num)) return v;
      
      const decimal = num % 1;
      
      if (decimal === 0.5) return Math.floor(num) + '½';
      if (decimal >= 0.84 && decimal <= 0.86) return Math.ceil(num) + '-';
      if (decimal >= 0.14 && decimal <= 0.16) return Math.floor(num) + '+';
      
      return v;
    }
    
    function parseCSVToObjects(text, delimiter = ',') {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines[0].split(delimiter).map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const cells = lines[i].split(delimiter);
        if (cells.length < headers.length) continue;
        let obj = {};
        headers.forEach((h, idx) => {
          obj[h] = cells[idx].trim();
        });
        data.push(obj);
      }
      
      return data;
    }
    
    
    
    function buildTable(data) {
      const tbody = document.querySelector('#votiTable tbody');
      tbody.innerHTML = '';
      
      let count = 1;
      data.forEach(row => {
        const tr = document.createElement('tr');
        
        const numTd = document.createElement('td');
        numTd.textContent = count++;
        tr.appendChild(numTd);
        
        const materiaTd = document.createElement('td');
        materiaTd.textContent = row.MATERIA;
        tr.appendChild(materiaTd);
        
        const dataTd = document.createElement('td');
        dataTd.textContent = row.DATA;
        tr.appendChild(dataTd);
        
        const votoTd = document.createElement('td');
        votoTd.textContent = formatVoto(row.VOTO);
        tr.appendChild(votoTd);
        
        const tipoTd = document.createElement('td');
        const tipo = row.TIPO.toLowerCase();
        let icon = '';
        if (tipo.includes('scritto')) {
          icon = '<span class="material-symbols-outlined" title="Scritto">description</span>';
        } else if (tipo.includes('orale')) {
          icon = '<span class="material-symbols-outlined" title="Orale">voice_selection</span>';
        } else if (tipo.includes('pratico')) {
          icon = '<span class="material-symbols-outlined" title="Pratico">steps</span>';
        } else {
          icon = row.TIPO;
        }
        tipoTd.innerHTML = icon;
        tr.appendChild(tipoTd);
        
        tbody.appendChild(tr);
      });
    }
    
    let allData = [];         // contiene tutti i dati CSV come array di oggetti
    let currentFilter = null; // materia selezionata, null = nessun filtro
    
    function buildMaterieList(data) {
      const container = document.getElementById('materieLista');
      container.innerHTML = '';
      
      // Raccogli dati per materia e tipo
      const materieMap = {};
      let totalCounts = { scritto: 0, orale: 0, pratico: 0 };
      
      data.forEach(row => {
        const materia = row.MATERIA;
        const tipo = row.TIPO.toLowerCase();
        
        if (!materieMap[materia]) materieMap[materia] = { scritto: 0, orale: 0, pratico: 0 };
        
        if (tipo.includes('scritto')) {
          materieMap[materia].scritto++;
          totalCounts.scritto++;
        } else if (tipo.includes('orale')) {
          materieMap[materia].orale++;
          totalCounts.orale++;
        } else if (tipo.includes('pratico')) {
          materieMap[materia].pratico++;
          totalCounts.pratico++;
        }
      });
      
      // Funzione helper icona+conteggio (come da te già scritta)
      function createTipoCount(iconName, count) {
        if (count === 0) return null;
        const tipoSpan = document.createElement('span');
        tipoSpan.className = 'tipo-count';
        tipoSpan.innerHTML = `<span class="material-symbols-outlined" title="${iconName}">${
        iconName === 'Scritto' ? 'description' :
        iconName === 'Orale' ? 'voice_selection' : 'steps'
        }</span> ${count}`;
        return tipoSpan;
      }
      
      // Aggiungo un "Tutti" per resettare filtro con totali e icone
      const tuttiItem = document.createElement('div');
      tuttiItem.className = 'materia-item' + (currentFilter === null ? ' active' : '');
      tuttiItem.textContent = 'Tutti ';
      
      // Aggiungo icone+conteggi totali a "Tutti"
      [ 
        { nome: 'Scritto', count: totalCounts.scritto },
        { nome: 'Orale', count: totalCounts.orale },
        { nome: 'Pratico', count: totalCounts.pratico }
      ].forEach(({ nome, count }) => {
        const span = createTipoCount(nome, count);
        if (span) tuttiItem.appendChild(span);
      });
      
      tuttiItem.onclick = () => {
        currentFilter = null;
        updateFilter();
      };
      container.appendChild(tuttiItem);
      
      // Crea gli elementi per ogni materia
      Object.entries(materieMap).forEach(([materia, counts]) => {
        const div = document.createElement('div');
        div.className = 'materia-item' + (currentFilter === materia ? ' active' : '');
        div.onclick = () => {
          currentFilter = materia;
          updateFilter();
        };
        
        // testo materia
        const textSpan = document.createElement('span');
        textSpan.textContent = materia;
        div.appendChild(textSpan);
        
        // icone e conteggi per materia
        const scrittoSpan = createTipoCount('Scritto', counts.scritto);
        const oraleSpan = createTipoCount('Orale', counts.orale);
        const praticoSpan = createTipoCount('Pratico', counts.pratico);
        
        [scrittoSpan, oraleSpan, praticoSpan].forEach(el => {
          if (el) div.appendChild(el);
        });
        
        container.appendChild(div);
      });
    }
    
    function updateFilter() {
      let filteredData = allData;
      
      if (selectedAnni.size > 0) {
        filteredData = filteredData.filter(d => selectedAnni.has(d.A));
      }
      
      if (currentFilter) {
        filteredData = filteredData.filter(d => d.MATERIA === currentFilter);
      }
      
      buildTable(filteredData);
      buildMaterieList(allData);
      buildAnniList(allData); // mostra tutti gli anni, ma attiva quelli selezionati
      renderChart();
    }
    let selectedChartType = 'tipo'; // default

    
    document.querySelectorAll('.chart-item').forEach(item => {
      item.addEventListener('click', () => {
        document.querySelectorAll('.chart-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        selectedChartType = item.dataset.type;
        renderChart();
      });
    });

    
    function handleCSVContent(csvText) {
      const delimiter = csvText.includes('\t') ? '\t' : ',';
      allData = parseCSVToObjects(csvText, delimiter);
      currentFilter = null;
      selectedAnni.clear();
      updateFilter();
    }
    
    let currentSort = {
      column: null,
      order: 'asc'
    };
    
    function sortTableBy(column) {
      if (currentSort.column === column) {
        currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.column = column;
        currentSort.order = 'asc';
      }
      
      let sortedData = [...allData];
      
      sortedData.sort((a, b) => {
        let valA = a[column];
        let valB = b[column];
        
        if (column === 'VOTO') {
          valA = parseFloat(valA.replace(',', '.')) || 0;
          valB = parseFloat(valB.replace(',', '.')) || 0;
        }
        
        if (column === 'DATA') {
          valA = new Date(valA);
          valB = new Date(valB);
        }
        
        if (valA < valB) return currentSort.order === 'asc' ? -1 : 1;
        if (valA > valB) return currentSort.order === 'asc' ? 1 : -1;
        return 0;
      });
      
      buildTable(sortedData);
    }
    
    document.getElementById('sortDateBtn').addEventListener('click', () => {
      sortTableBy('DATA');
    });
    
    document.getElementById('sortVotoBtn').addEventListener('click', () => {
      sortTableBy('VOTO');
    });
    
    let chart; // Chart.js instance
    
    function renderChart() {
      if (chart) chart.destroy();
      
      const type = selectedChartType;
      const data = getFilteredData();
      const years = Array.from(selectedAnni.size ? selectedAnni : new Set(allData.map(d => d.A)));
      
      const colors = years.map((y, i) => {
        return getComputedStyle(document.documentElement)
        .getPropertyValue(`--color-anno-${y}`)
        || `hsl(${(i * 60) % 360}, 70%, 50%)`;
      });
      
      const ctx = document.getElementById("myChart");
      
      if (type === "tipo") {
        const counts = {};
        data.forEach(d => counts[d.TIPO] = (counts[d.TIPO] || 0) + 1);
        
        chart = new Chart(ctx, {
          type: "pie",
          data: {
            labels: Object.keys(counts),
            datasets: [{
              data: Object.values(counts),
              backgroundColor: ["#4A90E2", "#E94E77", "#F5A623"]
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { position: "top" } }
          }
        });
        
      } else if (type === "quadrimestre") {
        const labels = ["1", "2"];
        const datasets = years.map((anno, i) => {
          const cnt = { "1": 0, "2": 0 };
          data.filter(d => d.A === anno).forEach(d => {
            if (d.Q in cnt) cnt[d.Q]++;
          });
          return {
            label: toRoman(parseInt(anno)),
            data: labels.map(l => cnt[l]),
            backgroundColor: colors[i].trim()
          };
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: { labels, datasets },
          options: {
            responsive: true,
            scales: { y: { beginAtZero: true } }
          }
        });
        
      } else if (type === "mese" || type === "media-mese") {
        const allMonths = [
          { idx: 8, label: "Set" },
          { idx: 9, label: "Ott" },
          { idx: 10, label: "Nov" },
          { idx: 11, label: "Dic" },
          { idx: 0, label: "Gen" },
          { idx: 1, label: "Feb" },
          { idx: 2, label: "Mar" },
          { idx: 3, label: "Apr" },
          { idx: 4, label: "Mag" },
          { idx: 5, label: "Giu" },
        ];
        
        const monthsWithData = allMonths.filter(({ idx }) =>
          years.some(anno =>
            data.some(d => {
              const mese = new Date(d.DATA).getMonth();
              return d.A === anno && mese === idx;
            })
          )
        );
        
        const monthLabels = monthsWithData.map(m => m.label);
        const monthOrder = monthsWithData.map(m => m.idx);
        
        if (type === "mese") {
          const datasets = years.map((anno, i) => {
            const cnt = Array(12).fill(0);
            data.filter(d => d.A === anno).forEach(d => {
              const m = new Date(d.DATA).getMonth();
              if (monthOrder.includes(m)) cnt[m]++;
            });
            const orderedData = monthOrder.map(idx => cnt[idx] === 0 ? null : cnt[idx]);
            return {
              label: toRoman(parseInt(anno)),
              data: orderedData,
              backgroundColor: colors[i].trim()
            };
          });
          
          chart = new Chart(ctx, {
            type: "bar",
            data: { labels: monthLabels, datasets },
            options: {
              responsive: true,
              scales: { y: { beginAtZero: true } }
            }
          });
          
        } else if (type === "media-mese") {
          const datasets = [];
          
          years.forEach((anno, i) => {
            const sum = Array(12).fill(0);
            const count = Array(12).fill(0);
            
            data.filter(d => d.A === anno).forEach(d => {
              const voto = parseFloat(d.VOTO);
              const dataDate = new Date(d.DATA);
              if (!isNaN(voto) && !isNaN(dataDate)) {
                const mese = dataDate.getMonth();
                if (monthOrder.includes(mese)) {
                  sum[mese] += voto;
                  count[mese]++;
                }
              }
            });
            
            const media = monthOrder.map(idx => count[idx] === 0 ? null : sum[idx] / count[idx]);
            
            datasets.push({
              label: toRoman(parseInt(anno)),
              data: media,
              fill: false,
              borderColor: colors[i].trim(),
              tension: 0,
              spanGaps: true
            });
          });
          
          chart = new Chart(ctx, {
            type: "line",
            data: { labels: monthLabels, datasets },
            options: {
              responsive: true,
              plugins: {
                legend: { position: "top" },
                tooltip: {
                  callbacks: {
                    label: ctx => ctx.dataset.label + ": " + ctx.formattedValue
                  }
                }
              },
              scales: {
                y: { beginAtZero: true, suggestedMax: 10 }
              }
            }
          });
        }
        
      }  else if (type === "linea-anno-continuo") {
        const sortedYears = years.map(y => parseInt(y)).sort((a, b) => a - b);
        
        const dataPoints = [];
        const annoPerPunto = [];
        
        sortedYears.forEach(anno => {
          const datiAnno = data
          .filter(d => parseInt(d.A) === anno)
          .sort((a, b) => new Date(a.DATA) - new Date(b.DATA));
          datiAnno.forEach(d => {
            dataPoints.push(parseFloat(d.VOTO));
            annoPerPunto.push(anno);
          });
        });
        
        const colors = sortedYears.map((anno, i) =>
          getComputedStyle(document.documentElement)
          .getPropertyValue(`--color-anno-${anno}`) || `hsl(${(i * 60) % 360}, 70%, 50%)`
        );
        
        chart = new Chart(ctx, {
          type: "line",
          data: {
            labels: dataPoints.map(() => ""),
            datasets: [{
              label: "",
              data: dataPoints,
              fill: false,
              tension: 0,
              spanGaps: true,
              borderColor: ctx => {
                const i = ctx.p0DataIndex;
                return colors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointRadius: 5,
              pointHoverRadius: 8,
              pointBackgroundColor: ctx => {
                const i = ctx.dataIndex;
                return colors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointBorderColor: ctx => {
                const i = ctx.dataIndex;
                return colors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointBorderWidth: 0,
              segment: {
                borderColor: ctx => {
                  const i = ctx.p0DataIndex;
                  return colors[sortedYears.indexOf(annoPerPunto[i])];
                }
              }
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                display: true,
                labels: {
                  generateLabels: chart => {
                    return sortedYears.map((anno, i) => ({
                      text: toRoman(anno),
                      fillStyle: colors[i].trim(),
                      strokeStyle: colors[i].trim(),
                      lineWidth: 2,
                      hidden: false,
                      datasetIndex: 0,
                      fontColor: "#666" // Se usi Chart.js v4: usa `color` al posto di `fontColor`
                    }));
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: ctx => `Voto: ${ctx.formattedValue}`
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                suggestedMax: 10
              },
              x: {
                ticks: { display: false },
                grid: { display: false }
              }
            }
          }
        });
      }
    }

    function getFilteredData() {
      let filtered = allData;
      if (selectedAnni.size > 0) {
        filtered = filtered.filter(d => selectedAnni.has(d.A));
      }
      if (currentFilter) {
        filtered = filtered.filter(d => d.MATERIA === currentFilter);
      }
      return filtered;
    }


    
    document.getElementById('csvFile').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        const content = event.target.result;
        localStorage.setItem('csvDataCache', content);
        handleCSVContent(content);
      };
      reader.readAsText(file);
    });
    
    // Al caricamento pagina: se c'è cache, la usa, altrimenti prova a caricare "miei.csv"
    const cached = localStorage.getItem('csvDataCache');
    if (cached) {
      handleCSVContent(cached);
    } else {
      fetch('miei.csv')
      .then(response => {
        if (!response.ok) throw new Error('File non trovato');
        return response.text();
      })
      .then(data => {
        localStorage.setItem('csvDataCache', data);
        handleCSVContent(data);
      })
      .catch(err => {
        console.warn('Caricamento automatico fallito:', err.message);
      });
    }
    
    Chart.defaults.color = '#ffffff';
    
    // Legenda
    Chart.defaults.plugins.legend.labels.color = '#ffffff';
    
    // Titolo (se in futuro ne aggiungi uno)
    Chart.defaults.plugins.title.color = '#ffffff';
    
    // Tooltip: testo e titolo
    Chart.defaults.plugins.tooltip.titleColor = '#ffffff';
    Chart.defaults.plugins.tooltip.bodyColor = '#ffffff';
    
    // Assi: ticks e label
    Chart.defaults.scales.x.ticks.color = '#ffffff';
    Chart.defaults.scales.y.ticks.color = '#ffffff';
    Chart.defaults.scales.x.title.color = '#ffffff';
    Chart.defaults.scales.y.title.color = '#ffffff';

  </script>
</body>
</html>
