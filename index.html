<!DOCTYPE html>
<html lang="it">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Voti</title>
  <style>
    /* Global Reset & Base */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    
    :root {
      --bg-dark: #0f0f0f;
      --bg-medium: #1c1c1c;
      --bg-light: #2a2a2a;
      --text-light: #e0e0e0;
      --text-muted: #aaa;
      --accent: #4A90E2;
      --border-color: #333;
      --hover-bg: #333333;
      --radius: 10px;
      --transition: 0.25s ease;
      --color-anno-1: #4A90E2;
      --color-anno-2: #E94E77;
      --color-anno-3: #F5A623;
      --color-anno-4: #7ED321;
      --color-anno-5: #50E3C2;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-light);
      margin: 0;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Scrollbar Hidden */
    .materie-lista,
    .anni-lista {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .materie-lista::-webkit-scrollbar,
    .anni-lista::-webkit-scrollbar {
      display: none;
    }
    
    /* Upload Styles */
    .file-upload {
      margin: 2rem 0;
    }
    .file-upload label {
      background-color: var(--bg-light);
      color: var(--text-light);
      padding: 0.6rem 1.4rem;
      border-radius: var(--radius);
      cursor: pointer;
      border: 1px solid var(--border-color);
      transition: background-color var(--transition);
    }
    .file-upload label:hover {
      background-color: var(--hover-bg);
    }
    .file-upload input {
      display: none;
    }
    
    /* Horizontal Lists (materie & anni) */
    .materie-lista,
    .anni-lista {
      width: 100%;
      max-width: 1000px;
      margin: 0 auto 1rem;
      display: flex;
      overflow-x: auto;
      padding: 0.5rem;
      background-color: var(--bg-medium);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
      white-space: nowrap;
      gap: 0.5rem;
    }
    .materia-item,
    .anno-item,
    .chart-item {
      flex-shrink: 0;
      padding: 0.4rem 1rem;
      background-color: var(--bg-light);
      color: var(--text-light);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.9rem;
      border: 1px solid transparent;
      user-select: none;
      text-align: center;
      transition: background-color var(--transition), border-color var(--transition);
    }
    .materia-item:hover,
    .anno-item:hover,
    .chart-item:hover,
    .materia-item.active,
    .anno-item.active,
    .chart-item.active {
      background-color: var(--hover-bg);
      border-color: #555;
    }
    
    /* Table Styles */
    .table-container {
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      overflow-x: auto;
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      background-color: var(--bg-medium);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      border-radius: var(--radius);
    }
    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 80px;
      border-bottom: 1px solid var(--border-color);
    }
    th {
      background-color: var(--bg-light);
      color: #fff;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background-color: #141414;
    }
    tr:last-child td {
      border-bottom: none;
    }
    
    /* Icon Buttons */
    .icon-button {
      background-color: var(--bg-light);
      color: var(--text-light);
      padding: 10px 16px;
      border-radius: var(--radius);
      cursor: pointer;
      border: 1px solid var(--border-color);
      transition: background-color var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon-button:hover {
      background-color: var(--hover-bg);
    }
    .icon-button .material-symbols-outlined {
      font-size: 20px;
      color: var(--text-light);
    }
    
    /* Sort Button */
    button.sort-button {
      all: unset;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: var(--text-light);
      font-family: inherit;
      user-select: none;
    }
    button.sort-button .material-symbols-outlined {
      font-size: 18px;
      color: var(--text-muted);
    }
    
    /* Chart Container & Tooltip */
    .chart-container {
      position: relative;
      width: 100%;
      max-width: 1000px;
      margin: 1rem auto;
      padding: 1rem;
      background-color: var(--bg-medium);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 320px;
      box-sizing: border-box;
      overflow: hidden;
    }
    #chartContainer {
      width: 100%;
      max-width: 700px;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .tooltip-popup {
      position: absolute;
      background-color: var(--bg-medium);
      color: var(--text-light);
      border: 1px solid var(--border-color);
      padding: 8px 12px;
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-family: inherit;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      z-index: 999;
      white-space: pre-line;
      pointer-events: none;
      max-width: 200px;
      overflow-wrap: break-word;
    }
    
    .file-upload .upload-buttons {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap; /* per schermi piccoli */
    }
    
    .file-upload .icon-button {
      background-color: var(--bg-light);
      color: var(--text-light);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      transition: background-color var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .file-upload .icon-button:hover {
      background-color: var(--hover-bg);
    }
    
    .file-upload .icon-button .material-symbols-outlined {
      font-size: 1.6rem;
      line-height: 1;
    }

    
    .materia-item {
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }
    .tipo-count {
      align-items: baseline;
    }
    .material-symbols-outlined {
      font-size: 1rem;
      vertical-align: top;
    }
    
    
    /* Rotate Warning */
    .rotate-warning {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      backdrop-filter: blur(8px);
      background-color: rgba(0, 0, 0, 0.6);
      color: #fff;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: 1rem;
      border-radius: var(--radius);
      z-index: 10;
    }
    .rotate-warning p {
      margin: 0;
      padding: 0 1rem;
    }
    .rotate-warning .material-symbols-outlined {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    /* Media Query for Portrait Warning */
    @media screen and (max-width: 767px) and (orientation: portrait) {
      #chartContainer {
        filter: blur(4px);
      }
      .rotate-warning {
        display: flex;
      }
    }
    
    /* Fixed Width Columns */
    #votiTable th:nth-child(1),
    #votiTable td:nth-child(1) { width: 40px; font-weight: bold; }
    #votiTable th:nth-child(2),
    #votiTable td:nth-child(2) { width: 180px; }
    #votiTable th:nth-child(3),
    #votiTable td:nth-child(3) { width: 100px; }
    #votiTable th:nth-child(4),
    #votiTable td:nth-child(4) { width: 70px; }
    #votiTable th:nth-child(5),
    #votiTable td:nth-child(5) { width: 70px; }
    
    /* Text Link Button */
    .ignore-blur-btn {
      all: unset;
      color: var(--accent);
      cursor: pointer;
      font-size: 0.95rem;
      text-decoration: underline;
      margin-top: 1rem;
    }
    .ignore-blur-btn:hover {
      text-decoration: none;
    }
    
    /* Responsive Padding */
    @media (max-width: 600px) {
      body {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  
  <!-- Grafico -->
  <div class="chart-container">
    <div id="chartContainer">
      <canvas id="myChart"></canvas>
    </div>
    <div class="rotate-warning">
      <span class="material-symbols-outlined">screen_rotation</span>
      <p>Ruota il telefono per visualizzare i grafici.</p>
    </div>
  </div>


  
  <!-- Menu di selezione grafico -->
  <!-- Selezione tipo di grafico (stile come anni-lista) -->
  <div class="anni-lista" id="chartSelector">
    <div class="chart-item" data-type="tipo">Tipo</div>
    <div class="chart-item" data-type="totali-per-anno">Anno</div>
    <div class="chart-item" data-type="voti-per-materia">Materia</div> 
    <div class="chart-item" data-type="quadrimestre">Quadrimestre</div>
    <div class="chart-item" data-type="mese">Mese</div>
    <div class="chart-item" data-type="giorno-settimana">Settimana</div>
    <div class="chart-item" data-type="media-mese">Media</div>
    <div class="chart-item" data-type="linea-anno-continuo">Linea Anno Continuo</div>
    <div class="chart-item" data-type="insufficienze">Insufficienze</div> 
    <div class="chart-item" data-type="numero">Numero</div> 
    <div class="chart-item" data-type="frequenza-voti">Frequenza</div> 
    <div class="chart-item" data-type="media-primo-quadrimestre">Media Q1</div>
    <div class="chart-item" data-type="media-secondo-quadrimestre">Media Q2</div>
    <div class="chart-item" data-type="confronto-materie">Confronto Q1 vs Q2</div>
  </div>
  
  <div class="anni-lista" id="anniLista"></div>
  <div class="materie-lista" id="materieLista"></div>
  <div class="table-container">
    <table id="votiTable">
      <thead>
        <tr>
          <th>#</th>
          <th>MATERIA</th>
          <th>
            DATA
            <button id="sortDateBtn" class="sort-button" data-order="asc" aria-label="Ordina per data">
              <span class="material-symbols-outlined">swap_vert</span>
            </button>
          </th>
          <th>
            VOTO
            <button id="sortVotoBtn" class="sort-button" data-order="asc" aria-label="Ordina per voto">
              <span class="material-symbols-outlined">swap_vert</span>
            </button>
          </th>
          <th>TIPO</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  
  <div class="file-upload">
    <div class="upload-buttons">
      <label for="csvFile">Carica file CSV</label>
      <button id="clearCacheBtn" class="icon-button" title="Cancella cache">
        <span class="material-symbols-outlined">delete</span>
      </button>
<!--  <button class="icon-button" title="Esporta dati">-->
<!--    <span class="material-symbols-outlined">download</span>-->
<!--  </button>-->
    </div>
    <input type="file" id="csvFile" accept=".csv" />
  </div>
  

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>

  <script>
    let selectedAnni = new Set(); // anni selezionati (es. "1A", "2A")

    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V"];
      return romans[num - 1] || num;
    }


    function buildAnniList(data) {
      const anniContainer = document.getElementById('anniLista');
      anniContainer.innerHTML = '';
      
      const anniSet = new Set(data.map(d => d.A));
      const anni = Array.from(anniSet).sort();
      
      anni.forEach(anno => {
        const div = document.createElement('div');
        div.className = 'anno-item' + (selectedAnni.has(anno) ? ' active' : '');
        const roman = toRoman(parseInt(anno));
        div.textContent = roman;
        div.onclick = () => {
          if (selectedAnni.has(anno)) {
            selectedAnni.delete(anno);
          } else {
            selectedAnni.add(anno);
          }
          updateFilter();
        };
        anniContainer.appendChild(div);
      });
    }
    
    
    
    function formatVoto(v) {
      const num = parseFloat(v);
      if (isNaN(num)) return v;
      
      const decimal = num % 1;
      
      if (decimal === 0.5) return Math.floor(num) + '½';
      if (decimal >= 0.84 && decimal <= 0.86) return Math.ceil(num) + '-';
      if (decimal >= 0.14 && decimal <= 0.16) return Math.floor(num) + '+';
      
      return v;
    }
    
    function parseCSVToObjects(text, delimiter = ',') {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines[0].split(delimiter).map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const cells = lines[i].split(delimiter);
        if (cells.length < headers.length) continue;
        let obj = {};
        headers.forEach((h, idx) => {
          obj[h] = cells[idx].trim();
        });
        data.push(obj);
      }
      
      return data;
    }
    
    function calcolaMedia(array) {
      const numeri = array.map(r => parseFloat(r.VOTO.replace(',', '.'))).filter(n => !isNaN(n));
      if (numeri.length === 0) return '-';
      return (numeri.reduce((a, b) => a + b, 0) / numeri.length).toFixed(2);
    }

    
    function buildTable(data, showStats = false) {
      const thead = document.querySelector('#votiTable thead');
      const tbody = document.querySelector('#votiTable tbody');
      
      // Pulisci tbody (dati)
      tbody.innerHTML = '';
      
      // Pulisci thead ma tieni riga intestazioni in una variabile
      const headerRow = thead.querySelector('tr:last-child');
      thead.innerHTML = '';
      
      if (showStats) {
        const voti = data.map(d => parseFloat(d.VOTO.replace(',', '.'))).filter(v => !isNaN(v));
        const totale = voti.length; // conteggio voti
        const massimo = voti.length ? Math.max(...voti) : 0;
        const minimo = voti.length ? Math.min(...voti) : 0;
        const media = voti.length ? (voti.reduce((acc, v) => acc + v, 0) / totale) : 0;
        
        // Riga 1: etichette statistiche con colonna vuota PRIMA
        const labelRow = document.createElement('tr');
        labelRow.classList.add('stats-row');
        ['', 'COUNT', 'MAX', 'MIN', 'AVG'].forEach(label => {
          const th = document.createElement('th');
          th.textContent = label;
          labelRow.appendChild(th);
        });
        
        // Riga 2: valori statistiche con colonna vuota PRIMA
        const valueRow = document.createElement('tr');
        valueRow.classList.add('stats-row');
        ['', totale, massimo, minimo, media.toFixed(2)].forEach(value => {
          const th = document.createElement('th');
          th.textContent = typeof value === 'number' ? formatVoto(value) : value;
          valueRow.appendChild(th);
        });
        
        
        // Inserisci prima le due righe statistiche
        thead.appendChild(labelRow);
        thead.appendChild(valueRow);
      }
      
      // Reinserisci la riga intestazioni
      thead.appendChild(headerRow);
      
      // Funzione per convertire numero in romano (1-5)
      function toRoman(num) {
        const romans = ["I", "II", "III", "IV", "V"];
        return romans[num - 1] || num;
      }
      
      // Funzione per ottenere giorno della settimana in italiano
      function getGiornoSettimana(date) {
        const giorni = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'];
        return giorni[date.getDay()];
      }
      
      // Costruisci tbody
      data.forEach(row => {
        const tr = document.createElement('tr');
        
        const numTd = document.createElement('td');
        numTd.textContent = row.INDEX; 
        tr.appendChild(numTd);
        
        const materiaTd = document.createElement('td');
        materiaTd.textContent = row.MATERIA;
        tr.appendChild(materiaTd);
        
        const dataTd = document.createElement('td');
        dataTd.textContent = row.DATA;
        
        // Parsing data "20 may 19"
        const parts = row.DATA.split(' ');
        if (parts.length === 3) {
          const day = parseInt(parts[0], 10);
          const monthStr = parts[1].toLowerCase();
          const yearShort = parseInt(parts[2], 10);
          const mesi = {
            'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5,
            'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
          };
          const month = mesi[monthStr];
          if (month !== undefined) {
            const fullYear = 2000 + yearShort;
            const dateObj = new Date(fullYear, month, day);
            const giornoSettimana = getGiornoSettimana(dateObj);
            const quadrimestre = row.Q || ''; // preso dal csv
            const annoScolastico = toRoman(parseInt(row.A)) || ''; // preso dal csv convertito in romano
            // … parsing della data, calcolo giorno/anno/quad …
            const infoTooltip = `${giornoSettimana},Anno:${annoScolastico},Quadrimestre:${quadrimestre}`;
            // Non uso più title, ma un attributo personalizzato:
            dataTd.setAttribute('data-info', infoTooltip);
            
            dataTd.addEventListener('click', () => {
              // Leggo la stringa dal data-info anziché da title
              const parts = dataTd.getAttribute('data-info').split(',');
              const giorno = parts[0]; // es "Martedì"
              const anno = parts[1].split(':')[1];       // es "II"
              const quadrimestre = parts[2].split(':')[1]; // es "1"
              
              const tooltipText = 
              `Giorno: ${giorno}\n` +
              `Anno scolastico: ${anno}\n` +
              `Quadrimestre: ${quadrimestre}`;
              
              showTooltip(dataTd, tooltipText);
            });
          }
        }
        tr.appendChild(dataTd);
        
        const votoTd = document.createElement('td');
        votoTd.textContent = formatVoto(row.VOTO);

        
        votoTd.addEventListener('click', (e) => {
          const thisDate = parseCSVDate(row.DATA);
          const thisMateria = row.MATERIA;
          
          const votiEntroData = data.filter(r => parseCSVDate(r.DATA) <= thisDate);
          const votiMateriaEntroData = votiEntroData.filter(r => r.MATERIA === thisMateria);
          
          const mediaGenerale = calcolaMedia(votiEntroData);
          const mediaMateria = calcolaMedia(votiMateriaEntroData);
          
          const mediaQ1 = calcolaMedia(votiMateriaEntroData.filter(r => r.Q === '1'));
          const mediaQ2 = calcolaMedia(votiMateriaEntroData.filter(r => r.Q === '2'));
          
          const tooltipText =
          `Media Generale: ${mediaGenerale}\n` +
          `${thisMateria}: ${mediaMateria}\n` +
          `Q1: ${mediaQ1} | Q2: ${mediaQ2}`;
          
          showTooltip(votoTd, tooltipText);
        });

        
        tr.appendChild(votoTd);
        
        const tipoTd = document.createElement('td');
        const tipo = row.TIPO.toLowerCase();
        let icon = '';
        if (tipo.includes('scritto')) {
          icon = '<span class="material-symbols-outlined" title="Scritto">description</span>';
        } else if (tipo.includes('orale')) {
          icon = '<span class="material-symbols-outlined" title="Orale">voice_selection</span>';
        } else if (tipo.includes('pratico')) {
          icon = '<span class="material-symbols-outlined" title="Pratico">steps</span>';
        } else {
          icon = row.TIPO;
        }
        tipoTd.innerHTML = icon;
        tr.appendChild(tipoTd);
        
        tbody.appendChild(tr);
      });
    }

    function parseCSVDate(dateStr) {
      const parts = dateStr.split(' ');
      const mesi = {
        'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5,
        'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
      };
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = mesi[parts[1].toLowerCase()];
        const year = 2000 + parseInt(parts[2], 10);
        return new Date(year, month, day);
      }
      return new Date('Invalid');
    }
    
    function calcolaMedia(votiRows) {
      const voti = votiRows
      .map(r => parseFloat(r.VOTO.replace(',', '.')))
      .filter(v => !isNaN(v));
      if (voti.length === 0) return '-';
      const somma = voti.reduce((acc, v) => acc + v, 0);
      return (somma / voti.length).toFixed(2);
    }


    const ignoreBtn = document.getElementById('ignoreBlurBtn');
    const chartContainer = document.getElementById('chartContainer');
    const rotateWarning = document.querySelector('.rotate-warning');
    
    
    let allData = [];         // contiene tutti i dati CSV come array di oggetti
    let currentFilter = null; // materia selezionata, null = nessun filtro
    
    let currentTooltip = null;
    
    let currentElement = null;
    
    function showTooltip(element, text) {
      if (currentElement === element && currentTooltip) return;
      
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
        currentElement = null;
      }
      
      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip-popup';
      tooltip.textContent = text;
      
      document.body.appendChild(tooltip);
      
      const rect = element.getBoundingClientRect();
      const tooltipWidth = tooltip.offsetWidth;
      const pageWidth = window.innerWidth;
      
      // Calcolo la posizione verticale
      const top = rect.top + window.scrollY - tooltip.offsetHeight - 10;
      
      let left = rect.left;
      
      // Se il tooltip esce a destra, lo sposto a sinistra rispetto all'elemento
      if (rect.left + tooltipWidth > pageWidth) {
        left = rect.right - tooltipWidth; // o rect.left - (tooltipWidth - element.offsetWidth)
        if (left < 0) left = 10; // fallback se anche a sinistra non c'è spazio
      }
      
      tooltip.style.position = 'absolute';
      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      
      currentTooltip = tooltip;
      currentElement = element;
      
      element.addEventListener('mouseleave', () => {
        if (currentTooltip) currentTooltip.remove();
        currentTooltip = null;
        currentElement = null;
      });
    }

    function buildMaterieList(data) {
      const container = document.getElementById('materieLista');
      container.innerHTML = '';
      
      // Raccogli dati per materia e tipo
      const materieMap = {};
      let totalCounts = { scritto: 0, orale: 0, pratico: 0 };
      
      data.forEach(row => {
        const materia = row.MATERIA;
        const tipo = row.TIPO.toLowerCase();
        
        if (!materieMap[materia]) materieMap[materia] = { scritto: 0, orale: 0, pratico: 0 };
        
        if (tipo.includes('scritto')) {
          materieMap[materia].scritto++;
          totalCounts.scritto++;
        } else if (tipo.includes('orale')) {
          materieMap[materia].orale++;
          totalCounts.orale++;
        } else if (tipo.includes('pratico')) {
          materieMap[materia].pratico++;
          totalCounts.pratico++;
        }
      });
  
      // Funzione helper icona+conteggio (come da te già scritta)
      function createTipoCount(iconName, count) {
        if (count === 0) return null;
        const tipoSpan = document.createElement('span');
        tipoSpan.className = 'tipo-count';
        tipoSpan.innerHTML = `<span class="material-symbols-outlined" title="${iconName}">${
        iconName === 'Scritto' ? 'description' :
        iconName === 'Orale' ? 'voice_selection' : 'steps'
        }</span> ${count}`;
        return tipoSpan;
      }
      
      // Aggiungo un "Tutti" per resettare filtro con totali e icone
      const tuttiItem = document.createElement('div');
      tuttiItem.className = 'materia-item' + (currentFilter === null ? ' active' : '');
      tuttiItem.textContent = 'Tutti ';
      
      // Aggiungo icone+conteggi totali a "Tutti"
      [ 
        { nome: 'Scritto', count: totalCounts.scritto },
        { nome: 'Orale', count: totalCounts.orale },
        { nome: 'Pratico', count: totalCounts.pratico }
      ].forEach(({ nome, count }) => {
        const span = createTipoCount(nome, count);
        if (span) tuttiItem.appendChild(span);
      });
      
      tuttiItem.onclick = () => {
        currentFilter = null;
        updateFilter();
      };
      container.appendChild(tuttiItem);
      
      // Crea gli elementi per ogni materia
      Object.entries(materieMap).forEach(([materia, counts]) => {
        const div = document.createElement('div');
        div.className = 'materia-item' + (currentFilter === materia ? ' active' : '');
        
//      div.onclick = () => {
//        currentFilter = materia;
//        updateFilter();
//      };

        div.onclick = () => {
          if (currentFilter === materia) {
            // Se la stessa materia è già selezionata, deseleziona e torna a 'Tutti'
            currentFilter = null;
          } else {
            currentFilter = materia;
            if (materia === 'Informatica') {
              launchPoopConfetti();
            }
          }
          updateFilter();
        };

        
        // testo materia
        const textSpan = document.createElement('span');
        textSpan.textContent = materia;
        div.appendChild(textSpan);
        
        // icone e conteggi per materia
        const scrittoSpan = createTipoCount('Scritto', counts.scritto);
        const oraleSpan = createTipoCount('Orale', counts.orale);
        const praticoSpan = createTipoCount('Pratico', counts.pratico);
        
        [scrittoSpan, oraleSpan, praticoSpan].forEach(el => {
          if (el) div.appendChild(el);
        });
        
        container.appendChild(div);
      });
    }

//===================================================================
//===================================================================
//===================================================================
//===================================================================
//  
//  function launchPoopConfetti() {
//    const numConfetti = 30;
//    for (let i = 0; i < numConfetti; i++) {
//      const confetto = document.createElement('div');
//      confetto.textContent = '💩';
//      confetto.style.position = 'fixed';
//      confetto.style.zIndex = 9999;
//      confetto.style.fontSize = '24px';
//      confetto.style.top = '-20px';
//      confetto.style.left = Math.random() * window.innerWidth + 'px';
//      confetto.style.transition = 'transform 2s ease-out, opacity 2s ease-out';
//      
//      document.body.appendChild(confetto);
//      
//      requestAnimationFrame(() => {
//        confetto.style.transform = `translateY(${Math.random() * 500 + 300}px) rotate(${Math.random() * 360}deg)`;
//        confetto.style.opacity = 0;
//      });
//      
//      setTimeout(() => confetto.remove(), 2000);
//    }
//  }

//===================================================================
//===================================================================
//===================================================================
//===================================================================
    
    function updateFilter() {
      // Filtro per anni
      let dataByAnno = allData;
      if (selectedAnni.size > 0) {
        dataByAnno = dataByAnno.filter(d => selectedAnni.has(d.A));
      }
      
      // Filtro per materia
      let dataByAnnoEMateria = dataByAnno;
      if (currentFilter) {
        dataByAnnoEMateria = dataByAnno.filter(d => d.MATERIA === currentFilter);
      }
      
      // Ordinamento
      if (currentSort.column) {
        dataByAnnoEMateria = dataByAnnoEMateria.slice().sort((a, b) => {
          let valA = a[currentSort.column];
          let valB = b[currentSort.column];
          
          if (currentSort.column === 'VOTO') {
            valA = parseFloat(valA.replace(',', '.')) || 0;
            valB = parseFloat(valB.replace(',', '.')) || 0;
          } else if (currentSort.column === 'DATA') {
            valA = new Date(valA);
            valB = new Date(valB);
          }
          
          if (valA < valB) return currentSort.order === 'asc' ? -1 : 1;
          if (valA > valB) return currentSort.order === 'asc' ? 1 : -1;
          return 0;
        });
      }
      
      // Mostro le due righe statistiche solo se ho filtro su anni o materia
      const showStats = (selectedAnni.size > 0) || (currentFilter !== null);
      
      // Costruisco la tabella con o senza righe statistiche
      buildTable(dataByAnnoEMateria, showStats);
      
      renderChart();
      buildMaterieList(dataByAnno);
      buildAnniList(allData);
    }


    
    let selectedChartType = 'tipo'; // default

    
    document.querySelectorAll('.chart-item').forEach(item => {
      item.addEventListener('click', () => {
        document.querySelectorAll('.chart-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        selectedChartType = item.dataset.type;
        renderChart();
      });
    });

    
    function handleCSVContent(csvText) {
      const delimiter = csvText.includes('\t') ? '\t' : ',';
      allData = parseCSVToObjects(csvText, delimiter);
      currentFilter = null;
      selectedAnni.clear();
      updateFilter();
    }
    
    let currentSort = {
      column: null,
      order: 'asc'
    };
    
    function sortTableBy(column) {
      if (currentSort.column === column) {
        currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.column = column;
        currentSort.order = 'asc';
      }
      
      updateFilter(); // aggiorno tabella e grafico con nuovo ordinamento + filtri
    }

    
    document.getElementById('sortDateBtn').addEventListener('click', () => {
      sortTableBy('DATA');
    });
    
    document.getElementById('sortVotoBtn').addEventListener('click', () => {
      sortTableBy('VOTO');
    });
    
    let chart; // Chart.js instance
    

    function renderChart() {
      if (chart) chart.destroy();
      
      const type = selectedChartType;
      const data = getFilteredData();
      const years = Array.from(selectedAnni.size ? selectedAnni : new Set(allData.map(d => d.A)))
      .sort((a, b) => parseInt(a) - parseInt(b));
      years.sort((a, b) => parseInt(a) - parseInt(b));
      const tipoFixedColors = ["#4A90E2", "#E94E77", "#F5A623"];
      
      const colors = years.map((y, i) => {
        return getComputedStyle(document.documentElement)
        .getPropertyValue(`--color-anno-${y}`)
        || `hsl(${(i * 60) % 360}, 70%, 50%)`;
      });
      
      const ctx = document.getElementById("myChart");
      
      if (type === "tipo") {
        const counts = {};
        data.forEach(d => counts[d.TIPO] = (counts[d.TIPO] || 0) + 1);
        
        chart = new Chart(ctx, {
          type: "pie",
          data: {
            labels: Object.keys(counts),
            datasets: [{
              data: Object.values(counts),
              backgroundColor: tipoFixedColors
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { position: "top" } }
          }
        });
        
      } else if (type === "voti-per-materia") {
        // Se non è stato selezionato nessun anno, prendi tutti gli anni disponibili
        const anni = selectedAnni.size > 0
        ? Array.from(selectedAnni)
        : Array.from(new Set(data.map(d => d.A)));
        
        // Ordina gli anni numericamente
        anni.sort((a, b) => parseInt(a) - parseInt(b));
        
        const filteredData = data.filter(d => anni.includes(d.A));
        
        // continua con il resto del codice usando "anni" e "filteredData"...
        const materie = Array.from(new Set(filteredData.map(d => d.MATERIA))).sort();
        const tipi = Array.from(new Set(filteredData.map(d => d.TIPO)));
        
        // colori soft HSL per ogni TIPO
        const tipoColors = {};
        tipi.forEach((tipo, i) => {
          tipoColors[tipo] = tipoFixedColors[i % tipoFixedColors.length];
        });
        
        // Struttura: anno → materia → tipo → count
        const counts = {};
        anni.forEach(anno => {
          counts[anno] = {};
          materie.forEach(materia => {
            counts[anno][materia] = {};
            tipi.forEach(tipo => {
              counts[anno][materia][tipo] = 0;
            });
          });
        });
        
        filteredData.forEach(d => {
          if (counts[d.A] && counts[d.A][d.MATERIA] && d.TIPO in counts[d.A][d.MATERIA]) {
            counts[d.A][d.MATERIA][d.TIPO]++;
          }
        });
        
        // Crea dataset impilati
        const datasets = [];
        anni.forEach((anno) => {
          tipi.forEach(tipo => {
            datasets.push({
              label: `${toRoman(parseInt(anno))} - ${tipo}`,
              data: materie.map(m => counts[anno][m][tipo]),
              backgroundColor: tipoColors[tipo],
              stack: `anno-${anno}`
            });
          });
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: materie,
            datasets: datasets
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              tooltip: { label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue}` }
            },
            scales: {
              x: {
                stacked: true,
                ticks: { color: "white" },
                grid: { display: false }
              },
              y: {
                beginAtZero: true,
                stacked: true,
                ticks: { color: "white" },
                grid: { color: "rgba(255,255,255,0.1)" }
              }
            }
          }
        });
      } else if (type === "totali-per-anno") {
        const counts = years.map(anno => {
          return data.filter(d => d.A === anno).length;
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: years.map(y => toRoman(parseInt(y))),
            datasets: [{
              label: "Totale voti",
              data: counts,
              backgroundColor: colors.map(c => c.trim())
            }]
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                ticks: { color: 'white' },
                grid: { color: 'rgba(0,0,0,0.1)' }
              },
              x: {
                ticks: { color: 'white' },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => `Totale voti: ${ctx.formattedValue}`
                }
              }
            }
          }
        });
      } else if (type === "giorno-settimana") {
        const giorniSettimana = ["Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì"];
        
        // Funzione per parsare date tipo "2 oct 20"
        const parseCustomDate = (str) => {
          const months = {
            jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5,
            jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11
          };
          const [day, monthStr, yearStr] = str.toLowerCase().split(" ");
          return new Date(2000 + parseInt(yearStr), months[monthStr], parseInt(day));
        };
        
        const datasets = years.map((anno, i) => {
          const counts = [0, 0, 0, 0, 0]; // Solo Lunedì (1) → Venerdì (5)
          
          data
          .filter(d => d.A === anno)
          .forEach(d => {
            const date = parseCustomDate(d.DATA);
            const giorno = date.getDay();
            if (giorno >= 1 && giorno <= 5) { // Solo giorni scolastici
              counts[giorno - 1]++; // Shiftiamo per allinearci con l’indice di counts (0=Lunedì)
            }
          });
          
          return {
            label: toRoman(parseInt(anno)),
            data: counts,
            backgroundColor: colors[i].trim()
          };
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: giorniSettimana,
            datasets
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                ticks: { color: 'white' },
                grid: { color: 'rgba(0,0,0,0.1)' }
              },
              x: {
                ticks: { color: 'white' },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { position: "top" },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label} - ${ctx.label}: ${ctx.formattedValue}`
                }
              }
            }
          }
        });
      } else if (type === "insufficienze") {
        const datasets = [{
          label: "Insufficienze (<6)",
          data: years.map(anno => {
            return data.filter(d => d.A === anno && parseFloat(d.VOTO) < 6).length;
          }),
          backgroundColor: colors.map(c => c.trim())
        }];
        
        // 🟢 Mostra solo le insufficienze anche nella tabella
//      const datiInsufficienze = data.filter(d => parseFloat(d.VOTO) < 6);
//      buildTable(datiInsufficienze);
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: years.map(y => toRoman(parseInt(y))),
            datasets
          },
          options: {
            responsive: true,
            scales: {
              y: { beginAtZero: true }
            },
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  afterBody: (tooltipItems) => {
                    const anno = years[tooltipItems[0].dataIndex];
                    const insufficienze = data.filter(d =>
                      d.A === anno && parseFloat(d.VOTO) < 6
                    );
                  },
                  label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue}`
                }
              }
            }
          }
        });
      } else if (type === "media-primo-quadrimestre") {
        // Trova tutte le materie nel dataset (solo dati Q=1)
        const materie = Array.from(new Set(data.filter(d => d.Q === "1").map(d => d.MATERIA)));
        
        // Costruiamo un dataset per ogni anno
        const datasets = years.map((anno, i) => {
          // Per ogni materia calcoliamo la media dei voti per quell'anno e Q=1
          const mediaPerMateria = materie.map(materia => {
            const voti = data.filter(d => d.A === anno && d.Q === "1" && d.MATERIA === materia)
            .map(d => parseFloat(d.VOTO))
            .filter(v => !isNaN(v));
            
            if (voti.length === 0) return null;
            const sum = voti.reduce((a, b) => a + b, 0);
            return sum / voti.length;
          });
          
          return {
            label: toRoman(parseInt(anno)),
            data: mediaPerMateria,
            fill: false,
            borderColor: colors[i].trim(),
            backgroundColor: colors[i].trim(),
            tension: 0,
            spanGaps: true
          };
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: materie,
            datasets
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                suggestedMax: 10,
                ticks: { color: 'white' },
                grid: { color: 'rgba(0,0,0,0.1)' }
              },
              x: {
                ticks: { color: 'white' },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { position: "top" },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label} - ${ctx.label}: ${ctx.formattedValue}`
                }
              },
              annotation: {
                annotations: {
                  line1: {
                    type: 'line',
                    yMin: 6,
                    yMax: 6,
                    borderColor: 'gray',
                    borderWidth: 2,
                    borderDash: [6, 6], // linee tratteggiate: 6px linea, 6px spazio
                    label: {
                      enabled: true,
                      content: '',
                      color: 'gray',
                      position: 'start'
                    }
                  }
                }
              }
            }
          }

        });
      } else if (type === "numero") {
        // 1. Prepara i giorni da 1 a 31
        const giorni = Array.from({ length: 31 }, (_, i) => i + 1);
        
        // 2. Inizializza i conteggi per ogni giorno
        const suffPerGiorno = Array(31).fill(0);
        const insuffPerGiorno = Array(31).fill(0);
        
        data.forEach(d => {
          const parts = d.DATA.split(' ');
          const giorno = parseInt(parts[0], 10);
          
          const voto = parseFloat(d.VOTO);
          if (!isNaN(giorno) && giorno >= 1 && giorno <= 31 && !isNaN(voto)) {
            if (voto >= 6) {
              suffPerGiorno[giorno - 1]++;
            } else {
              insuffPerGiorno[giorno - 1]++;
            }
          }
        });
        
        // 3. Crea il grafico con due dataset impilati
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: giorni.map(g => g.toString()),
            datasets: [
              {
                label: "Sufficienze",
                data: suffPerGiorno,
                backgroundColor: "#48C936",
                stack: 'voti'
              },
              {
                label: "Insufficienze",
                data: insuffPerGiorno,
                backgroundColor: "#C73232",
                stack: 'voti'
              }
            ]
          },
          options: {
            responsive: true,
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Giorno del mese",
                  color: "white"
                },
                ticks: { color: "white" },
                grid: { display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { display: false }, // <-- NASCONDE I VALORI Y
                grid: { color: "rgba(255,255,255,0.1)" }
              }
            },
            plugins: {
              legend: {
                labels: { color: "white" }
              },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue} voto/i`
                }
              }
            }
          }
        });
      } else if (type === "frequenza-voti") {
        const votiUnici = Array.from(new Set(data.map(d => d.VOTO.toString())))
        .map(v => parseFloat(v))
        .filter(v => !isNaN(v));
        votiUnici.sort((a, b) => a - b);
        
        const materie = Array.from(new Set(data.map(d => d.MATERIA))).sort();
        
        const materiaColors = {};
        materie.forEach((m, i) => {
          const hue = Math.round((i * 360) / materie.length);
          materiaColors[m] = `hsl(${hue}, 60%, 50%)`;
        });
        
        const counts = {};
        votiUnici.forEach(voto => {
          counts[voto] = {};
          materie.forEach(materia => {
            counts[voto][materia] = 0;
          });
        });
        
        data.forEach(d => {
          const votoNum = parseFloat(d.VOTO);
          const mat = d.MATERIA;
          if (!isNaN(votoNum) && counts[votoNum] && counts[votoNum][mat] !== undefined) {
            counts[votoNum][mat]++;
          }
        });
        
        const datasets = materie.map(materia => {
          return {
            label: materia,
            data: votiUnici.map(voto => counts[voto][materia]),
            backgroundColor: materiaColors[materia]
          };
        });
        
        if (chart) {
          chart.destroy();
        }
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: votiUnici.map(v => formatVoto(v)), // 🟢 etichette X formattate
            datasets: datasets
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "white"
                }
              },
              tooltip: {
                callbacks: {
                  label: context => {
                    const mat = context.dataset.label;
                    const cnt = context.parsed.y;
                    return `${mat}: ${cnt}`;
                  }
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                title: {
                  display: true,
                  text: "Voti",
                  color: "white"
                },
                ticks: {
                  color: "white",
                  callback: function(val, index) {
                    const label = this.getLabelForValue(val);
                    return formatVoto(label);
                  }
                },
                grid: { display: false }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: { display: false },
                grid: { drawBorder: false, color: "rgba(255,255,255,0.1)" }
              }
            }
          }
        });
      } else if (type === "media-secondo-quadrimestre") {
        // Trova tutte le materie nel dataset (solo dati Q=2)
        const materie = Array.from(new Set(data.filter(d => d.Q === "2").map(d => d.MATERIA)));
        
        // Costruiamo un dataset per ogni anno
        const datasets = years.map((anno, i) => {
          // Per ogni materia calcoliamo la media dei voti per quell'anno e Q=2
          const mediaPerMateria = materie.map(materia => {
            const voti = data.filter(d => d.A === anno && d.Q === "2" && d.MATERIA === materia)
            .map(d => parseFloat(d.VOTO))
            .filter(v => !isNaN(v));
            
            if (voti.length === 0) return null;
            const sum = voti.reduce((a, b) => a + b, 0);
            return sum / voti.length;
          });
          
          return {
            label: toRoman(parseInt(anno)),
            data: mediaPerMateria,
            fill: false,
            borderColor: colors[i].trim(),
            backgroundColor: colors[i].trim(),
            tension: 0,
            spanGaps: true
          };
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: materie,
            datasets
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                suggestedMax: 10,
                ticks: { color: 'white' },
                grid: { color: 'rgba(0,0,0,0.1)' }
              },
              x: {
                ticks: { color: 'white' },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { position: "top" },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label} - ${ctx.label}: ${ctx.formattedValue}`
                }
              },
              annotation: {
                annotations: {
                  line1: {
                    type: 'line',
                    yMin: 6,
                    yMax: 6,
                    borderColor: 'gray',
                    borderWidth: 2,
                    borderDash: [6, 6], // linee tratteggiate: 6px linea, 6px spazio
                    label: {
                      enabled: true,
                      content: '',
                      color: 'gray',
                      position: 'start'
                    }
                  }
                }
              }
            }
          }
        });
      } else if (type === "confronto-materie") {
        const materie = Array.from(new Set(data.map(d => d.MATERIA)));
        
        const datasets = [];
        
        years.forEach((anno, i) => {
          const colorBase = colors[i].trim();
          
          // Primo quadrimestre (Q=1)
          const mediaQ1 = materie.map(materia => {
            const voti = data.filter(d => d.A === anno && d.Q === "1" && d.MATERIA === materia)
            .map(d => parseFloat(d.VOTO)).filter(v => !isNaN(v));
            if (voti.length === 0) return null;
            return voti.reduce((a, b) => a + b, 0) / voti.length;
          });
          
          datasets.push({
            label: `${toRoman(parseInt(anno))} - Q1`,
            data: mediaQ1,
            backgroundColor: colorBase,
            borderColor: colorBase,
            borderWidth: 1
          });
          
          // Secondo quadrimestre (Q=2)
          const mediaQ2 = materie.map(materia => {
            const voti = data.filter(d => d.A === anno && d.Q === "2" && d.MATERIA === materia)
            .map(d => parseFloat(d.VOTO)).filter(v => !isNaN(v));
            if (voti.length === 0) return null;
            return voti.reduce((a, b) => a + b, 0) / voti.length;
          });
          
          datasets.push({
            label: `${toRoman(parseInt(anno))} - Q2`,
            data: mediaQ2,
            backgroundColor: colorBase,
            borderColor: colorBase,
            borderWidth: 1,
            borderDash: [4, 4] // visivamente differenziabile
          });
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: materie,
            datasets
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                suggestedMax: 10,
                ticks: { color: 'white' },
                grid: { color: 'rgba(0,0,0,0.1)' }
              },
              x: {
                ticks: { color: 'white' },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { position: "top" },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label} - ${ctx.label}: ${ctx.formattedValue}`
                }
              },
              annotation: {
                annotations: {
                  line1: {
                    type: 'line',
                    yMin: 6,
                    yMax: 6,
                    borderColor: 'gray',
                    borderWidth: 2,
                    borderDash: [6, 6], // linee tratteggiate: 6px linea, 6px spazio
                    label: {
                      enabled: true,
                      content: '',
                      color: 'gray',
                      position: 'start'
                    }
                  }
                }
              }
            }
          }
        });
      } else if (type === "quadrimestre") {
        const labels = ["1", "2"];
        const datasets = years.map((anno, i) => {
          const cnt = { "1": 0, "2": 0 };
          data.filter(d => d.A === anno).forEach(d => {
            if (d.Q in cnt) cnt[d.Q]++;
          });
          return {
            label: toRoman(parseInt(anno)),
            data: labels.map(l => cnt[l]),
            backgroundColor: colors[i].trim()
          };
        });
        
        chart = new Chart(ctx, {
          type: "bar",
          data: { labels, datasets },
          options: {
            responsive: true,
            scales: { y: { beginAtZero: true } }
          }
        });
        
      } else if (type === "mese" || type === "media-mese") {
        const allMonths = [
          { idx: 8, label: "Set" }, { idx: 9, label: "Ott" }, { idx: 10, label: "Nov" }, { idx: 11, label: "Dic" },
          { idx: 0, label: "Gen" }, { idx: 1, label: "Feb" }, { idx: 2, label: "Mar" }, { idx: 3, label: "Apr" },
          { idx: 4, label: "Mag" }, { idx: 5, label: "Giu" },
        ];
        
        const monthsWithData = allMonths.filter(({ idx }) =>
          years.some(anno =>
            data.some(d => {
              const mese = new Date(d.DATA).getMonth();
              return d.A === anno && mese === idx;
            })
          )
        );
        
        const monthLabels = monthsWithData.map(m => m.label);
        const monthOrder = monthsWithData.map(m => m.idx);
        
        if (type === "mese") {
          const datasets = years.map((anno, i) => {
            const cnt = Array(12).fill(0);
            data.filter(d => d.A === anno).forEach(d => {
              const m = new Date(d.DATA).getMonth();
              if (monthOrder.includes(m)) cnt[m]++;
            });
            const orderedData = monthOrder.map(idx => cnt[idx] === 0 ? null : cnt[idx]);
            return {
              label: toRoman(parseInt(anno)),
              data: orderedData,
              backgroundColor: colors[i].trim()
            };
          });
          
          chart = new Chart(ctx, {
            type: "bar",
            data: { labels: monthLabels, datasets },
            options: {
              responsive: true,
              scales: { y: { beginAtZero: true } }
            }
          });
          
        } else if (type === "media-mese") {
          const datasets = [];
          
          years.forEach((anno, i) => {
            const sum = Array(12).fill(0);
            const count = Array(12).fill(0);
            
            data.filter(d => d.A === anno).forEach(d => {
              const voto = parseFloat(d.VOTO);
              const dataDate = new Date(d.DATA);
              if (!isNaN(voto) && !isNaN(dataDate)) {
                const mese = dataDate.getMonth();
                if (monthOrder.includes(mese)) {
                  sum[mese] += voto;
                  count[mese]++;
                }
              }
            });
            
            const media = monthOrder.map(idx => count[idx] === 0 ? null : sum[idx] / count[idx]);
            
            datasets.push({
              label: toRoman(parseInt(anno)),
              data: media,
              fill: false,
              borderColor: colors[i].trim(),
              tension: 0,
              spanGaps: true
            });
          });
          
          chart = new Chart(ctx, {
            type: "line",
            data: { labels: monthLabels, datasets },
            options: {
              responsive: true,
              plugins: {
                legend: { position: "top" },
                tooltip: {
                  callbacks: {
                    label: ctx => ctx.dataset.label + ": " + ctx.formattedValue
                  }
                }
                
              },
              scales: {
                y: { beginAtZero: true, suggestedMax: 10 }
              }
            }
          });
        }
        
      } else if (type === "linea-anno-continuo") {
        const sortedYears = years.map(y => parseInt(y)).sort((a, b) => a - b);
        
        const dataPoints = [];
        const annoPerPunto = [];
        const infoPerPunto = [];  // per tipo e data
        
        sortedYears.forEach(anno => {
          const datiAnno = data
          .filter(d => parseInt(d.A) === anno)
          .sort((a, b) => new Date(a.DATA) - new Date(b.DATA));
          datiAnno.forEach(d => {
            dataPoints.push(parseFloat(d.VOTO));
            annoPerPunto.push(anno);
            infoPerPunto.push({ tipo: d.TIPO, data: d.DATA });
          });
        });
        
        const lineColors = sortedYears.map((anno, i) =>
          getComputedStyle(document.documentElement)
          .getPropertyValue(`--color-anno-${anno}`)
          || `hsl(${(i * 60) % 360}, 70%, 50%)`
        );
        
        chart = new Chart(ctx, {
          type: "line",
          data: {
            labels: dataPoints.map(() => ""),
            datasets: [{
              label: "",
              data: dataPoints,
              fill: false,
              tension: 0,
              spanGaps: true,
              borderColor: ctx => {
                const i = ctx.p0DataIndex;
                return lineColors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointRadius: 5,
              pointHoverRadius: 8,
              pointBackgroundColor: ctx => {
                const i = ctx.dataIndex;
                return lineColors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointBorderColor: ctx => {
                const i = ctx.dataIndex;
                return lineColors[sortedYears.indexOf(annoPerPunto[i])];
              },
              pointBorderWidth: 0,
              segment: {
                borderColor: ctx => {
                  const i = ctx.p0DataIndex;
                  return lineColors[sortedYears.indexOf(annoPerPunto[i])];
                }
              }
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                display: true,
                labels: {
                  // questo imposta il colore di default, ma poi generateLabels lo sovrascrive:
                  color: 'white',
                  generateLabels: chart => {
                    return sortedYears.map((anno, i) => ({
                      text: toRoman(anno),
                      fillStyle: lineColors[i].trim(),
                      strokeStyle: lineColors[i].trim(),
                      lineWidth: 2,
                      hidden: false,
                      datasetIndex: 0,
                      // aggiungi esplicitamente il colore del testo:
                      color: 'white',      // Chart.js v4
                      fontColor: 'white'   // Chart.js v2/3
                    }));
                  }
                }
              },
              tooltip: {
                titleColor: "white",
                bodyColor: "white",
                callbacks: {
                  label: ctx => {
                    const i = ctx.dataIndex;
                    const voto = ctx.formattedValue;
                    const tipo = infoPerPunto[i].tipo;
                    const dataStr = new Date(infoPerPunto[i].data).toLocaleDateString();
                    return `Voto: ${voto}, ${tipo}, ${dataStr}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                suggestedMax: 10,
                ticks: { color: 'white' },
                grid: { color: 'rgba(255,255,255,0.1)' }
              },
              x: {
                ticks: { display: false }, // se vuoi nascondere asse x, altrimenti metti color: 'white'
                grid: { display: false }
              }
            }
          } 
          
        })
      } 
    }

    function getFilteredData() {
      let filtered = allData;
      if (selectedAnni.size > 0) {
        filtered = filtered.filter(d => selectedAnni.has(d.A));
      }
      if (currentFilter) {
        filtered = filtered.filter(d => d.MATERIA === currentFilter);
      }
      return filtered;
    }


    
    document.getElementById('csvFile').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        const content = event.target.result;
        localStorage.setItem('csvDataCache', content);
        handleCSVContent(content);
      };
      reader.readAsText(file);
    });
    
    document.getElementById('clearCacheBtn').addEventListener('click', function () {
      localStorage.removeItem('csvDataCache');
      location.reload(); // (facoltativo) ricarica la pagina per ripristinare lo stato iniziale
    });

const cached = localStorage.getItem('csvDataCache');
    if (cached) {
      handleCSVContent(cached);
    } else {
      fetch('miei.csv')
      .then(response => {
        if (!response.ok) throw new Error('File non trovato');
        return response.text();
      })
      .then(data => {
        localStorage.setItem('csvDataCache', data);
        handleCSVContent(data);
      })
      .catch(err => {
        console.warn('Caricamento automatico fallito:', err.message);
      });
    }
    
    Chart.defaults.color = '#ffffff';
    
    // Legenda
    Chart.defaults.plugins.legend.labels.color = '#ffffff';
    
    // Titolo (se in futuro ne aggiungi uno)
    Chart.defaults.plugins.title.color = '#ffffff';
    
    // Tooltip: testo e titolo
    Chart.defaults.plugins.tooltip.titleColor = '#ffffff';
    Chart.defaults.plugins.tooltip.bodyColor = '#ffffff';
    
    // Assi: ticks e label
    Chart.defaults.scales.x.ticks.color = '#ffffff';
    Chart.defaults.scales.y.ticks.color = '#ffffff';
    Chart.defaults.scales.x.title.color = '#ffffff';
    Chart.defaults.scales.y.title.color = '#ffffff';

  </script>
</body>
</html>